#!/usr/bin/env ruby

# Bad block detective. See:
# https://www.dzhang.com/blog/2018/04/16/identifying-file-associated-with-bad-sector-ext2-ext3-ext4
# https://superuser.com/questions/490787/reverse-lookup-of-inode-file-from-offset-in-raw-device-on-linux-and-ext3-4

require 'optparse'
require_relative '../lib/ruby/disk/info'
require_relative '../lib/ruby/format_helpers'

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: bad-blocks -d device [-D fs-device] block..."

  opts.on('-h', '--help', 'Show usage') do
    puts opts.help
    exit
  end

  # E.g. /dev/sda
  opts.on("-d", "--device DEVICE", "Device of physical drive") do |v|
    options[:device] = v
  end

  # E.g. /dev/mapper/XXX for luks devices
  opts.on("-D", "--fs-device DEVICE", "Device for filesystem") do |v|
    options[:fs_device] = v
  end

  opts.on('-f', '--from LBA', 'Check range from this LBA') do |v|
    options[:start_lba] = v
  end

  opts.on('-t', '--to LBA', 'Check range to this LBA') do |v|
    options[:end_lba] = v
  end

  opts.on('-x', '--hex', 'LBAs are given in hex') do
    options[:hex] = true
  end

  opts.on('-s', '--smart', 'Read bad blocks from SMART background scan log') do
    options[:smart_log] = true
  end

  opts.on('-b', '--block-size SIZE', 'Block size (512, 4096)') do |v|
    options[:block_size] = Integer(v)
  end

  opts.on('-w', '--write', 'Write to the identified blocks') do
    options[:write] = true
  end
end.parse!

if start_lba = options[:start_lba]
  if options[:hex]
    start_lba = Integer(start_lba, 16)
  else
    start_lba = Integer(start_lba)
  end
  options[:start_lba] = start_lba
end

if end_lba = options[:end_lba]
  if options[:hex]
    end_lba = Integer(end_lba, 16)
  else
    end_lba = Integer(end_lba)
  end
  options[:end_lba] = end_lba
end

unless device = options[:device]
  raise 'Device is required'
end

unless block_size = options[:block_size]
  require_relative '../lib/ruby/disk/info'
  info = Disk::Info.new(device)
  block_size = info.block_size
  puts "Using block size: #{block_size}"
end

if options[:start_lba] && !ARGV.empty?
  raise 'start LBA provided and block number'
end

if options[:end_lba] && !ARGV.empty?
  raise 'start LBA provided and block number'
end

if ARGV.length > 1
  raise NotImplementedError
end

if options[:start_lba] || options[:end_lba]
  raise 'Should not happen'
end

options[:start_lba] = options[:end_lba] = Integer(ARGV.shift)

disk_info = Disk::Info.new(device)

if options[:smart_log]
  log = Disk::Info.background_scan_log_entries(device)
  bad_lbas = log.select do |entry|
    entry.dig(:reassign_status, :value) == 1
  end.map do |entry|
    entry.fetch(:lba)
  end
  puts "Bad LBAs from SMART: #{bad_lbas.join(', ')}"
else
  start_lba = options.fetch(:start_lba)
  end_lba = options.fetch(:end_lba)
  puts "Starting at block #{start_lba} with block size of #{block_size} - #{FormatHelpers.friendly_size(start_lba * block_size)} into the disk"
  if block_size != disk_info.block_size
    warn "requested block size of #{block_size} but disk block size is #{disk_info.block_size}"
    start_lba = start_lba * block_size / disk_info.block_size
    end_lba = (end_lba * block_size / disk_info.block_size.to_f).ceil
    warn "new limits: from #{start_lba} to #{end_lba}"
    block_size = disk_info.block_size
  end
  cmd = "badblocks -b #{block_size} #{device} #{end_lba} #{start_lba}"
  puts cmd
  output = `#{cmd}`
  puts output
  if $?.exitstatus != 0
    raise 'badblocks failed'
  end
  bad_lbas = output.split("\n").map { |v| Integer(v) }
  if bad_lbas.none?
    warn 'no bad blocks found'
    exit
  end
end

if options[:write]
  bad_lbas.each do |lba|
    puts "Writing: #{lba} to #{device}"
    system("sg_dd if=/dev/zero of=#{device} bs=#{block_size} seek=#{lba} count=1")
  end
else
  partition_offset = 256
  fs_lbas = bad_lbas.map { |lba| lba - partition_offset }

  fs_device = options[:fs_device] || device
  output = `debugfs -R "icheck #{fs_lbas.join(' ')}" #{fs_device}`
  puts output
  inodes = Set.new
  output.split("\n")[1..].each do |line|
    lba, inode = line.split("\t", 2).map do |v|
      if v == '<block not found>'
        nil
      else
        Integer(v)
      end
    end
    if inode
      inodes << inode
    end
  end

  output = `debugfs -R "ncheck #{inodes.join(' ')}" #{fs_device}`
  puts output
  output.split("\n")[1..].each do |line|
    inode, path = line.split("\t", 2)
  end
end
