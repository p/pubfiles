#!/usr/bin/env ruby

require 'json'
require 'yaml'
require 'optparse'

# Path to the Claude configuration file
CLAUDE_CONFIG_PATH = File.expand_path('~/.claude.json')

# Parse command line options
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: claude-conf [options] [directory]"

  opts.on("-f", "--state-file FILE", "State file path for YAML (default: stdout for extract, stdin for merge)") do |file|
    options[:state_file] = file
  end

  opts.on("-a", "--auth", "Export authentication-related parameters") do
    options[:auth] = true
  end

  opts.on("-m", "--merge", "Merge settings from YAML file into Claude config") do
    options[:merge] = true
  end

  opts.on("--reset-install-method", "Reset the installMethod field in Claude config") do
    options[:reset_install_method] = true
  end

  opts.on("--theme THEME", "Set theme (dark, light, dark-ansi, light-ansi, dark-colorblind, light-colorblind) [values generated by Claude, not verified]") do |theme|
    options[:theme] = theme
  end

  opts.on("-s", "--sandbox", "Enable sandbox mode (--dangerously-skip-permissions) for current directory") do
    options[:sandbox] = true
  end

  opts.on("-r", "--run", "Merge configuration (if -f given) and exec claude binary") do
    options[:run] = true
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end
end.parse!

# Get optional directory argument
target_directory = ARGV[0]
if target_directory
  target_directory = File.expand_path(target_directory)
  unless File.directory?(target_directory)
    $stderr.puts "Error: '#{target_directory}' is not a valid directory"
    exit 1
  end
end

# Determine if we need to modify config
should_merge = options[:merge] || (options[:run] && options[:state_file])
needs_modification = options[:reset_install_method] || options[:theme] || options[:sandbox] || should_merge

if needs_modification
  # Read YAML data first if merging
  auth_data = nil
  if should_merge
    begin
      if options[:state_file]
        yaml_path = File.expand_path(options[:state_file])
        yaml_content = File.read(yaml_path)
      else
        yaml_content = $stdin.read
      end
      auth_data = YAML.load(yaml_content)
    rescue Errno::ENOENT => e
      $stderr.puts "Error: #{e.message}"
      exit 1
    rescue Psych::SyntaxError => e
      $stderr.puts "Error parsing YAML: #{e.class}: #{e}"
      exit 1
    end
  end

  # Read existing config or create new one (for merge mode)
  begin
    config_content = File.read(CLAUDE_CONFIG_PATH)
    config_data = JSON.parse(config_content)
  rescue Errno::ENOENT
    if should_merge
      # File doesn't exist, create empty config for merge
      config_data = {}
    else
      $stderr.puts "Error: #{CLAUDE_CONFIG_PATH} not found"
      exit 1
    end
  rescue JSON::ParserError => e
    $stderr.puts "Error parsing JSON from #{CLAUDE_CONFIG_PATH}: #{e.class}: #{e}"
    exit 1
  end

  # Handle reset-install-method
  if options[:reset_install_method]
    config_data.delete('installMethod')
  end

  # Handle theme
  if options[:theme]
    config_data['theme'] = options[:theme]
  end

  # Handle sandbox
  if options[:sandbox]
    config_data['dangerouslySkipPermissions'] = options[:sandbox]
    config_data['bypassPermissionsModeAccepted'] = true

    # If --run is also given, set trust for target directory
    if options[:run]
      project_path = target_directory || Dir.pwd
      config_data['projects'] ||= {}
      config_data['projects'][project_path] ||= {}
      config_data['projects'][project_path]['hasTrustDialogAccepted'] = true
    end
  end

  # Handle merge
  if should_merge && auth_data
    config_data['primaryApiKey'] = auth_data['api_key'] if auth_data['api_key']
    config_data['oauthAccount'] = auth_data['oauth_account'] if auth_data['oauth_account']
    config_data['userID'] = auth_data['user_id'] if auth_data['user_id']
    config_data['customApiKeyResponses'] = auth_data['custom_api_key_responses'] if auth_data['custom_api_key_responses']
    config_data['hasCompletedOnboarding'] = true
  end

  # Write updated config back
  begin
    File.write(CLAUDE_CONFIG_PATH, JSON.pretty_generate(config_data))
  rescue => e
    $stderr.puts "Error writing config file to #{CLAUDE_CONFIG_PATH}: #{e.class}: #{e}"
    exit 1
  end
else
  # Extract mode: read config and write to YAML
  begin
    config_content = File.read(CLAUDE_CONFIG_PATH)
    config_data = JSON.parse(config_content)
  rescue Errno::ENOENT
    $stderr.puts "Error: #{CLAUDE_CONFIG_PATH} not found"
    exit 1
  rescue JSON::ParserError => e
    $stderr.puts "Error parsing JSON from #{CLAUDE_CONFIG_PATH}: #{e.class}: #{e}"
    exit 1
  end

  # Extract authentication data (only if -a option is specified)
  auth_data = {}
  if options[:auth]
    auth_data = {
      'api_key' => config_data['primaryApiKey'],
      'oauth_account' => config_data['oauthAccount'],
      'user_id' => config_data['userID'],
      'custom_api_key_responses' => config_data['customApiKeyResponses']
    }
  end

  # Write to YAML file or stdout
  begin
    if options[:state_file]
      yaml_path = File.expand_path(options[:state_file])
      File.write(yaml_path, auth_data.to_yaml)
    else
      puts auth_data.to_yaml
    end
  rescue => e
    $stderr.puts "Error writing YAML: #{e.class}: #{e}"
    exit 1
  end
end

# Handle run option
if options[:run]
  # Change to target directory if specified
  Dir.chdir(target_directory) if target_directory

  if options[:sandbox]
    exec('claude', '--dangerously-skip-permissions')
  else
    exec('claude')
  end
end
