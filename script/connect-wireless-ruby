#!/usr/bin/env ruby

# Inspiration: https://github.com/dmelo/vswm

autoload :YAML, 'yaml'
autoload :FileUtils, 'fileutils'
autoload :Tempfile, 'tempfile'
autoload :JSON, 'json'
autoload :OptionParser, 'optparse'
#gem 'childprocess'
autoload :ChildProcess, 'childprocess'

class Error < StandardError
end

class WpaSupplicantFailed < Error
end

class InterfaceNotFound < Error
end

class NoIpAddress < Error
end

class NoDefaultGateway < Error
end

class CalledProcessError < Error
end

module Sub

  module_function def uncheck_call(cmd, env: nil)
    start_process(cmd, env: env).tap do |process|
      process.wait
    end
  end

  module_function def start_and_forward(cmd, env: nil)
    puts "[CWR] Starting: #{cmd.join(' ')}"
    process = ChildProcess.new(*cmd)
    process.io.inherit!
    rd, wr = IO.pipe
    apply_env(process, env)
    process.start
    p process.wait
  end

  module_function def check_call(cmd, env: nil)
    process = uncheck_call(cmd, env: env)
    check_exit_code(process, cmd)
  end

  module_function def check_output(cmd, env: nil)
    puts "[CWR] Get output: #{cmd.join(' ')}"
    process = ChildProcess.new(*cmd)
    process.io.inherit!
    process.io.stdout = Tempfile.new("child-output")
    process.io.stderr = Tempfile.new("child-error")
    begin
      apply_env(process, env)
      process.start
      process.wait
      check_exit_code(process, cmd)
      process.io.stdout.rewind
      process.io.stdout.read
    ensure
      process.io.stdout.close
      process.io.stderr.close
    end
  end

  module_function def start_process(cmd, env: nil)
    puts "[CWR] Starting: #{cmd.join(' ')}"
    process = ChildProcess.new(*cmd)
    process.io.inherit!
    apply_env(process, env)
    process.start
    process
  end

  module_function def start_process_pipe(cmd, env: nil)
    puts "[CWR] Starting pipe: #{cmd.join(' ')}"
    rd, wr = IO.pipe
    pid = fork do
      rd.close
      STDOUT.reopen(wr)
      STDERR.reopen(wr)
      wr.close

      if env
        env.each do |k, v|
          ENV[k] = v
        end
      end

      exec(*cmd)
    end

    wr.close
    cmd_name = File.basename(cmd.first)
    thread = Thread.new do
      loop do
        chunk = rd.readline
        if chunk.nil?
          break
        end
        STDOUT << "[#{cmd_name}] #{chunk}"
      rescue EOFError
        # swallow
      end
    end

    {pid: pid, thread: thread}
  end

  private

  module_function def apply_env(process, env)
    if env
      env.each do |k, v|
        process.environment[k.to_s] = v
      end
    end
  end

  module_function def format_cmd(cmd)
    cmd.join(' ')
  end

  module_function def check_exit_code(process, cmd)
    unless process.exit_code == 0
      raise CalledProcessError, "Failed to execute: #{format_cmd(cmd)} (exit code #{process.exit_code})"
    end
  end
end

module Utils
  module_function def monotime
    Process.clock_gettime(Process::CLOCK_MONOTONIC)
  end

  module_function def have(basename)
    !!path_dirs.detect do |dir|
      File.exist?(File.join(dir, basename))
    end
  end

  private

  module_function def path_dirs
    @path_dirs ||= ENV.fetch('PATH').split(':')
  end
end

class Runner
  def initialize(**opts)
    @options = opts.dup.freeze

    if auto?
      @keep_wired_up = !!begin
        Sub.check_output(%w(dmidecode -s system-family)).strip =~ /^ThinkPad X280/
      rescue CalledProcessError
        false
      end
    end
  end

  attr_reader :options

  def keep_wired_up?
    @keep_wired_up
  end

  def ssid
    options.fetch(:ssid)
  end

  def password
    options[:password]
  end

  def state_dir
    options.fetch(:state_dir)
  end

  def auto?
    !!options[:auto]
  end

  def connected_wired?
    @connected == :wired
  end

  def connected_wireless?
    @connected == :wireless
  end

  def run
    identify_interfaces

    if auto? && keep_wired_up?
      wired_ifnames.each do |ifname|
        Sub.uncheck_call(['ifconfig', ifname, 'up'])
      end
    end

    %w(ifdown ifup dhclient wpa_supplicant).each do |proc_name|
      Sub.uncheck_call(['pkill', proc_name])
    end

    done = false
    if auto? && wired_ifnames.any?
      if @wired_ifname = find_active_wired_ifname
        puts "Wired interface up: #{wired_ifname}"
        connect_wired
        done = true
      end
    end

    unless done
      connect_wireless
    end
  end

  def remove_ips(ifname)
    # https://superuser.com/questions/153559/how-can-i-clear-the-ip-address-of-ethernet-interface-without-cycling-the-interfa
    Sub.check_call(['ip', 'addr', 'flush', 'dev', ifname])
  end

  def connect_wireless
    @connected = nil

    if auto? && keep_wired_up?
      wired_ifnames.each do |ifname|
        remove_ips(ifname)
      end
    else
      wired_ifnames.each do |ifname|
        Sub.uncheck_call(['ifconfig', ifname, 'down'])
      end
    end

    @wireless_ifname = wireless_ifnames.first
    unless wireless_ifname
      raise "No wireless interfaces?"
    end

    %w(ifdown ifup dhclient wpa_supplicant).each do |proc_name|
      Sub.uncheck_call(['pkill', '-9', proc_name])
    end

    if have_ifdown = Utils.have('ifdown')
      Sub.uncheck_call(['ifdown', wireless_ifname])
      wired_ifnames.each do |ifname|
        Sub.uncheck_call(['ifdown', ifname])
      end
    end

    unblock_rfkill

    start_wpa_supplicant

    puts('Running dhclient')
    Sub.check_call(['dhclient', '-v', wireless_ifname])

    FileUtils.mkdir_p(state_dir)
    path = File.join(state_dir, 'config.json')
    @config = {
      ssid: ssid,
      password: password,
      interface: wireless_ifname,
      ip: get_if_ip(wireless_ifname),
      gateway: get_default_gateway,
    }
    File.open(path, 'w') do |f|
      f << JSON.dump(@config)
    end

    @connected = :wireless

    #if options[:keep]
      keep
    #end
  end

  def find_active_wired_ifname
    wired_ifnames.detect do |ifname|
      path = "/sys/class/net/#{ifname}/operstate"
      begin
        File.read(path).strip == 'up'
      rescue IOError, SystemCallError
        false
      end
    end
  end

  def connect_wired
    @connected = nil

    wireless_ifnames.each do |ifname|
      remove_ips(ifname)
    end

    Sub.check_call(['dhclient', '-v', wired_ifname])

    # Assuming, should check that the connection actually worked.
    @connected = :wired
  end

  def keep
    unless password
      loop do
        sleep 10
      end
    end

    need_start = false
    loop do
      begin
        if need_start
          start_wpa_supplicant
          need_start = false
        end

        get_current_state

        if auto? && ifname = state[:active_wired_ifname]
          unless connected_wired?
            @wired_ifname = ifname
            connect_wired
            sleep 3
          end
          sleep 3
          next
        end

        # Checking WPA state here even if password isn't set - the block
        # should never activate since without password there won't be any
        # WPA state to begin with.
        if state[:wpa_completed]
          sleep 3
          next
        end

        if state[:no_ssid]
          raise WpaSupplicantFailed, 'ssid is off/any, bad auth to wpa supplicant?'
        end

        # TODO check that the current SSID is the one that was requested
        # by the user.

        if password
          if (elapsed = Utils.monotime - started_at) > options.fetch(:wpa_supplicant_timeout)
            raise WpaSupplicantFailed, "Giving up on wpa association after #{options.fetch(:wpa_supplicant_timeout)} seconds"
          end

          if @wpa_exited
            raise WpaSupplicantFailed, "wpa_supplicant unexpectedly terminated with exit code #{wpa_process.exit_code}"
          end
        end

        puts 'ssid: %s, wpa: %s, elapsed: %d' % [state[:ssid], state[:wpa_state], elapsed]
        sleep 3
      rescue WpaSupplicantFailed
        need_start = true
        Sub.uncheck_call(%w(pkill -9 wpa_supplicant))
        sleep 1
      end
    end
  end

  private

  attr_reader :wired_ifnames
  attr_reader :wired_ifname
  attr_reader :wireless_ifnames
  attr_reader :wireless_ifname

  def identify_interfaces
    wireless = []
    wired = []

    output = Sub.check_output(%w(iwconfig))
    # "no wireless extensions" lines are printed to standard error
    output.split(/[\r\n]+/).each do |line|
      if line =~ %r,\A(\w+),
        ifname = $1
        wireless << ifname
      end
    end

    output = Sub.check_output(%w(ip -j a))
    infos = {}
    JSON.parse(output).each do |info|
      if info.fetch('link_type') == 'ether'
        ifname = info.fetch('ifname')
        unless wireless.include?(ifname)
          wired << ifname
        end
      end
    end

    @wired_ifnames = wired
    @wireless_ifnames = wireless
  end

  def get_if_ip(ifname)
    output = Sub.check_output(['ip', '-j', 'address', 'show', ifname])
    result = JSON.parse(output)
    if ai = result.first['addr_info']
      if ai.empty?
        raise NoIpAddress, "Empty addr_info for #{ifname}"
      end
      ai = ai.first
      unless (family = ai.fetch('family')) == 'inet'
        raise "Unhandled family: #{family}"
      end
      ai.fetch('local')
    else
      raise NoIpAddress, "No IP address for #{ifname}"
    end
  end

  def get_default_gateway
    lines = Sub.check_output(%w(netstat -rn)).split("\n")
    lines.each do |line|
      if line.start_with?('0.0.0.0')
        return line.split(/\s+/, 2).first
      end
    end
    raise NoDefaultGateway
  end

  def unblock_rfkill
    if Utils.have('rfkill')
      output = Sub.check_output(%w(rfkill))
      output.split("\n").each do |line|
        id, type, device, soft, hard = line.strip.split(/\s+/)
        if type == 'wlan' && soft == 'blocked'
          puts("Unblocking rfkill")
          Sub.check_call(['rfkill', 'unblock', id])
        end
      end
    end
  end

  attr_reader :wpa_process_info
  attr_reader :started_at

  def start_wpa_supplicant
    puts "[CWR] Preparing to start wpa_supplicant for #{wireless_ifname}"
    if @wpa_process_info
      begin
        Process.kill('TERM', @wpa_process_info.fetch(:pid))
      rescue SystemCallError
      end
      begin
        @wpa_process_info.fetch(:thread).kill
      rescue ThreadError
      end
      @wpa_process_info = nil
    end
    @wpa_exited = false
    @wpa_process_info = {}

    dir = '/etc/network/interfaces.d'
    if File.exist?(dir)
      contents = "iface #{wireless_ifname} inet dhcp\n"
      if password
        contents << "  wpa-ssid \"#{ssid}\"\n"
      else
        contents << "  wireless-essid \"#{ssid}\""
      end
      File.open(File.join(dir, wireless_ifname), 'w') do |f|
        f << contents
      end
    end

    Sub.check_call(['iwconfig', wireless_ifname, 'essid', ssid])

    if password
      continue_starting_wpa_supplicant
    else
      @started_at = Utils.monotime
    end
  end

  def continue_starting_wpa_supplicant
    contents = <<-EOT
      ctrl_interface=/run/wpa_supplicant
      #ap_scan=0
      network={
        scan_ssid=1
        ssid="#{ssid}"
        key_mgmt=WPA-PSK
        psk="#{password}"
      }
EOT
    wpa_conf_path = File.join('/etc/network/wpa_supplicant.conf.d', wireless_ifname)
    File.open(wpa_conf_path, 'w') do |f|
      f << contents
    end

    begin
      Sub.check_call(%W(wpa_cli -i #{wireless_ifname} status))
    rescue CalledProcessError
    else
      Sub.check_call(%W(wpa_cli -i #{wireless_ifname} terminate))
      sleep 1
    end

    puts("Starting wpa_supplicant for #{wireless_ifname}")
    wpa_supplicant_log_path = '/tmp/wpa_supplicant.log'
    # TODO detach from controlling terminal here
    binary = 'wpa_supplicant'
    #binary = '/home/me/apps/exp/hostap/wpa_supplicant/wpa_supplicant'
    @wpa_process_info = Sub.start_process_pipe([binary,
      '-D', 'nl80211,wext', '-i', wireless_ifname,
      #'-f', wpa_supplicant_log_path,
      '-c', wpa_conf_path, '-d',
    ])
    if File.exist?(wpa_supplicant_log_path)
      FileUtils.chmod(0o644, wpa_supplicant_log_path)
    end

    Thread.new do
      pid = wpa_process_info.fetch(:pid)
      exitstatus = Process.waitpid(pid)
      puts "wpa supplicant exited with #{$?.exitstatus}"
      wpa_process_info[:exit_status] = $?.exitstatus
    ensure
      @wpa_exited = true
    end

    @started_at = Utils.monotime
    loop do
      get_current_state

      if state[:no_ssid]
        raise WpaSupplicantFailed, 'ssid is off/any, bad auth to wpa supplicant?'
      end

      if state[:wpa_completed]
        break
      end

      if (elapsed = Utils.monotime - started_at) > options.fetch(:wpa_supplicant_timeout)
        raise WpaSupplicantFailed, "Giving up on wpa association after #{options.fetch(:wpa_supplicant_timeout)} seconds"
      end

      if @wpa_exited
        status = wpa_process_info[:exit_status]
        if status
          raise WpaSupplicantFailed, "wpa_supplicant unexpectedly terminated with exit code #{status}"
        else
          raise WpaSupplicantFailed, "wpa_supplicant unexpectedly terminated and exit code is not available"
        end
      end

      puts 'ssid: %s, wpa: %s, elapsed: %d' % [state[:ssid], state[:wpa_state], elapsed]
      sleep 1
    end
  rescue CalledProcessError => exc
    new_exc = WpaSupplicantFailed.new("#{exc.class}: #{exc}")
    new_exc.backtrace = exc.backtrace
    raise new_exc
  end

  attr_reader :state

  def get_current_state
    output = Sub.check_output(['iwconfig', wireless_ifname])
    state = {associated: false}
    if output =~ /\bESSID:"([^"]*)"/
      state[:ssid] = $1
    elsif output =~ /\bESSID:([^\s]+)/
      state[:ssid] = $1
    end
    if state[:ssid] == 'off/any'
      state[:no_ssid] = true
    end

    if output =~ /Access Point: (?:[0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}/
      state[:associated] = true
    end

    if password
      begin
        output = Sub.check_output(%W(wpa_cli -i #{wireless_ifname} status))
      rescue CalledProcessError
      else
        if output =~ /\bwpa_state=(\w+)/
          state[:wpa_state] = $1
        end
        state[:wpa_completed] = state[:wpa_state] == 'COMPLETED'
      end
    end

    if auto?
      state[:active_wired_ifname] = find_active_wired_ifname
    end

    @state = state.compact
  end

  def default_gw_ok?
    output = Sub.check_output(%w(netstat -rn))
    lines = output.split("\n").select do |line|
      line.start_with?('0.0.0.0')
    end
    if lines.length > 1
      puts "Multiple default gateways??"
      return false
    end
    if lines.length == 0
      puts "No default gateway"
      return false
    end
    gw = lines.first.split(/\s+/)[1]
    puts "Default gateway: #{gw}"
    true
  end

  def start_dhclient
    Sub.uncheck_call(%w(pkill dhclient))
    Sub.check_call(['dhclient', '-v', wireless_ifname])
  end
end

options = {
  wpa_supplicant_timeout: 60,
  state_dir: '/run/wireless',
}
OptionParser.new do |opts|
  opts.banner = "Usage: connect-wireless [options] ssid [password]"

  opts.on("-a", "--auto", "Auto switch between wired & wireless") do
    options[:auto] = true
  end

  opts.on("-r", "--resume", "Restore configuration after wake-up") do
    options[:resume] = true
  end

  opts.on("-k", "--keep", "Stay running to maintain specified configuration") do
    options[:keep] = true
  end

  opts.on("-d", "--daemon", "Daemonize") do
    options[:daemonize] = true
  end

  opts.on("-P", "--pidfile PATH", "Path to pidfile when daemonizing") do |v|
    options[:pidfile_path] = v
  end

  opts.on("-l", "--log PATH", "Log to specified path instead of standard output") do |v|
    options[:log_path] = v
  end

  opts.on("-t", "--wpa-supplicant-timeout TIMEOUT", "Timeout to wait for wpasupplicant") do |v|
    options[:wpa_supplicant_timeout] = Float(v)
  end

  opts.on('-w', '--known', 'Resolve argument as a known network') do
    options[:known] = true
  end

  opts.on('--state-dir PATH', 'Path to state directory to use') do |v|
    options[:state_dir] = v
  end
end.parse!

ssid, password = ARGV
if ssid.nil?
  raise 'Usage'
end

if options[:known]
  if password
    raise "Password cannot be given when using a known network"
  end

  dir = File.join(File.dirname(__FILE__), '../config/wireless-networks')
  unless File.exist?(dir)
    raise "Missing known networks directory: #{dir}"
  end
  networks = {}
  Dir.entries(dir).each do |bn|
    next if bn == '.' || bn == '..'
    begin
      this_contents = File.open(File.join(dir, bn)) do |f|
        YAML.load(f)
      end
      networks.update(this_contents)
    rescue Psych::Exception => exc
      puts "Error loading #{bn}: #{exc.class}: #{exc}"
    end
  end

  info = networks[ssid]
  unless info
    raise "Network alias #{ssid} not known"
  end
  ssid = info.fetch('ssid')
  password = info['password']

  puts "Connecting to #{ssid}"
end

if options[:daemonize]
  unless options[:log_path]
    raise "Log destination must be specified when daemonizing"
  end

  unless options[:pidfile_path]
    raise "Pidfile path must be specified when daemonizing"
  end
end

Runner.new(**options.merge(ssid: ssid, password: password)).run
