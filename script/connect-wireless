#!/usr/bin/env python3

# Inspiration: https://github.com/dmelo/vswm

import sys, subprocess, re, os, os.path, time as _time, json, argparse

def identify_interfaces():
    wireless = []
    dev_null = open('/dev/null', 'w')
    try:
        output = subprocess.check_output(['/sbin/iwconfig'], stderr=dev_null).decode()
    finally:
        dev_null.close()
    for line in output.split('\n'):
        match = re.match(r'(\w+)\s+IEEE 802.11', line)
        if match:
            wireless.append(match.group(1))
    output = subprocess.check_output(['ip', 'a']).decode()
    wired = []
    for line in output.split("\n"):
        match = re.match(r'\d+: (\w+):', line)
        if match:
            interface_name = match.group(1)
            type = None
        match = re.match(r'\s+link/(\w+)', line)
        if match:
            type = match.group(1)
            if type == 'ether' and interface_name not in wireless:
                wired.append(interface_name)
    return dict(wired=wired, wireless=wireless)

def get_if_ip(ifname):
    output = subprocess.check_output(['/sbin/ifconfig', ifname]).decode()
    match = re.search(r'inet (\S+)', output)
    if not match:
        raise Exception('not found')
    return match.group(1)

def get_default_gateway():
    output = subprocess.check_output(['netstat', '-rn']).decode()
    for line in output.split("\n"):
        if line.startswith('0.0.0.0'):
            gw = re.split(r'\s+', line)[1]
            return gw
    raise 'No default gateway'

def start(network, password):
    global config
    
    for process in ['ifdown', 'ifup', 'dhclient', 'wpa_supplicant']:
        subprocess.call(['pkill', '-9', process])

    interfaces = identify_interfaces()
    wireless_interface = interfaces['wireless'][0]

    for interface in interfaces['wired']:
        subprocess.call(['ifdown', interface])
    subprocess.call(['ifdown', wireless_interface])
    _time.sleep(1)
    start_wpa_supplicant(wireless_interface, network, password)
    print('Running dhclient')
    subprocess.check_call(['dhclient', '-v', wireless_interface])

    if not os.path.exists('/run/wireless'):
        os.mkdir('/run/wireless')

    config = {
        'network': network,
        'password': password,
        'interface': wireless_interface,
        'ip': get_if_ip(wireless_interface),
        'gateway': get_default_gateway(),
    }
        
    with open('/run/wireless/config.json', 'w') as f:
        json.dump(config, f)

def read_config():
    with open('/run/wireless/config.json') as f:
        return json.load(f)

def get_current_status(interface):
    output = subprocess.check_output(['/sbin/iwconfig', interface]).decode()
    status = {'associated': False}
    match = re.search(r'ESSID:"([^"]*)"', output)
    if not match:
        match = re.search(r'ESSID:([^\s]*)', output)
    status['network'] = match.group(1)
    if re.search(r'Access Point: (?:[0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}', output):
        status['associated'] = True
    return status

def check_and_resume(config):
    interface = config['interface']
    status = get_current_status(interface)
    print(config)
    print(status)
    if status['network'] != config['network']:
        print('Expected network %s, current network %s, reconnecting' % (config['network'], status['network']))
        start_wpa_supplicant(config['interface'], config['network'], config['password'])
    elif not status['associated']:
        print('Not associated, restarting wpa supplicant')
        start_wpa_supplicant(config['interface'], config['network'], config['password'])

def resume():
    global config
    config = read_config()
    check_and_resume(config)

def start_wpa_supplicant(interface, network, password):
    contents = 'iface %s inet dhcp\n' % interface
    if password:
        contents += '  wpa-ssid "%s"\n  wpa-psk "%s"\n' % (network, password)
    else:
        contents += '  wireless-essid %s' % network

    with open('/etc/network/interfaces.d/%s' % interface, 'w') as f:
        f.write(contents)

    contents = "ctrl_interface=/run/wpa_supplicant\n"
    contents += 'network={\n  ssid="%s"' % network
    if password:
        contents += '\n  key_mgmt=WPA-PSK\n  psk="%s"' % password
    contents += '\n}\n'

    wpa_conf_path = '/etc/network/wpa_supplicant.conf.d/%s' % interface
    if not os.path.exists('/etc/network/wpa_supplicant.conf.d'):
        os.mkdir('/etc/network/wpa_supplicant.conf.d')
    with open(wpa_conf_path, 'w') as f:
        f.write(contents)

    try:
        subprocess.check_call(['wpa_cli', 'status'])
    except subprocess.CalledProcessError:
        pass
    else:
        subprocess.check_call(['wpa_cli', 'terminate'])
        _time.sleep(1)
    
    subprocess.check_call(['iwconfig', interface, 'essid', network])
    print('Starting wpa_supplicant')
    subprocess.check_call(['wpa_supplicant', '-B',
        '-D', 'nl80211,wext',
        '-i', interface,
        '-f', '/tmp/wpa_supplicant.log',
        '-c', wpa_conf_path])
    os.chmod('/tmp/wpa_supplicant.log', 0o644)
    
    start_time = _time.monotonic()
    while True:
        try:
            output = subprocess.check_output(['wpa_cli', 'status']).decode()
        except subprocess.CalledProcessError:
            continue
            
        if 'wpa_state=COMPLETED' in output:
            break
        
        #print(output)
        
        if _time.monotonic() - start_time > 10:
            raise Exception('giving up on wpa association after 10 seconds')
            
        _time.sleep(1)

def keep():
    global config
    config = read_config()
    interface = config['interface']
    while True:
        check_and_resume(config)
        _time.sleep(5)

parser = argparse.ArgumentParser(description='Connect to a wireless network')
parser.add_argument('ssid', type=str, nargs='?',
                    help='Specify SSID')
parser.add_argument('password', type=str, nargs='?',
                    help='Specify password')
parser.add_argument('-r', '--resume', action='store_const', const=True,
                    help='Restore configuration after wake-up')
parser.add_argument('-k', '--keep', action='store_const', const=True,
                    help='Stay running to maintain specified configuration')

args = parser.parse_args()

if args.resume:
    if args.ssid:
        print('ssid/password input is not allowed when resuming')
        exit(3)
    resume()
elif args.ssid:
    start(args.ssid, args.password)
else:
    print('Takes ssid or ssid & password or the --resume option')
    exit(3)

if args.keep:
    keep()
