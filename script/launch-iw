#!/usr/bin/env ruby

# https://www.ghacks.net/2016/08/14/override-firefox-add-on-signing-requirement/
# https://firefox-source-docs.mozilla.org/mozbase/mozprofile.html

require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: launch-iw [-c cert] [-e ext.xpi] [-u user] binary profile"

  opts.on("-c", "--ca=PATH", "Add a CA certificate to trust store") do |value|
    options[:ca_certs] ||= []
    options[:ca_certs] << value
  end

  opts.on("-e", "--ext PATH", "Load unpacked extension at PATH") do |v|
    options[:extensions] ||= []
    options[:extensions] << v
  end

  opts.on("-u", "--user USER", "Launch as given user") do |v|
    options[:user] = v
  end
end.parse!

binary, profile = ARGV

if profile.nil?
  raise "Usage: launch-iw [-u user] binary profile"
end

require 'etc'

def run(cmd)
  joined = cmd.join(' ')
  puts "Executing #{joined}"
  if pid = fork
    Process.wait(pid)
    if $?.exitstatus != 0
      raise "Failed to run #{joined}: process exited with code #{$?.exitstatus}"
    end
  else
    exec(*cmd)
  end
end

target_user = options[:user] || profile
unless target_user.start_with?('br-')
  target_user = "br-#{target_user}"
end
if Etc.getpwuid(Process.euid).name != target_user
  begin
    Etc.getpwnam(target_user)
  rescue ArgumentError => e
    if e.message =~ /can't find user/
      if options[:user]
        # User was explicitly requested
        raise
      else
        # Ignore
      end
    else
      raise
    end
  else
    puts "Relaunching as #{target_user}"
    cmd = ['sudo', '-nu', target_user, 'id']
    run(cmd)
    auths = `xauth list`.strip.split("\n")
    auths.each do |auth|
      cmd = ['sudo', '-nu', target_user,
        'env', "XAUTHORITY=/home/#{target_user}/.Xauthority",
        'xauth', 'add'] + auth.split(/\s+/)
      run(cmd)
    end
    if certs = options[:ca_certs]
      certs.each do |ca_path|
        ARGV << '-c' << ca_path
      end
    end
    cmd = %w(sudo -nu) + [target_user, 'env', "XAUTHORITY=/home/#{target_user}/.Xauthority", File.realpath(File.expand_path($0))]
    options[:extensions]&.each do |ext|
      cmd += ['-e', ext]
    end
    cmd += ARGV
    puts "Executing #{cmd.join(' ')}"
    exec(*cmd)
  end
end

profile_dir = case File.basename(binary)
when 'waterfox'
  if binary =~ /waterfox-classic/
    '.waterfox-classic'
  else
    '.waterfox'
  end
when 'firefox'
  '.mozilla/firefox'
when 'palemoon'
  '.moonchild productions/pale moon'
else
  raise "Unknown browser #{binary}"
end

catalog_dir = File.join(File.expand_path('~'), profile_dir)

catalog_path = File.join(catalog_dir, 'profiles.ini')
profile_basename = "gen.#{profile}"
profile_path = File.join(catalog_dir, profile_basename)

require 'inifile'
require 'fileutils'
require 'tmpdir'
require 'json'
require 'firefox_hash_generator'

if File.exist?(catalog_path)
  ini = IniFile.new(filename: catalog_path, separator: '')
else
  ini = IniFile.new(separator: '')
end

ini['Profile0'] = {
  Name: profile,
  IsRelative: 1,
  Path: profile_basename,
}

FileUtils.mkdir_p(catalog_dir)
ini.write(filename: catalog_path)

FileUtils.mkdir_p(profile_path)

src = File.expand_path(File.join(File.dirname(__FILE__), '../home/mozilla'))

chrome_path = File.join(profile_path, 'chrome')
FileUtils.mkdir_p(chrome_path)
FileUtils.ln_sf(File.join(src, 'userChrome.css'), File.join(chrome_path, 'userChrome.css'))
FileUtils.ln_sf(File.join(src, 'userContent.css'), File.join(chrome_path, 'userContent.css'))
FileUtils.ln_sf(File.join(src, 'user.js'), File.join(profile_path, 'user.js'))
unless File.exist?(File.join(profile_path, 'system'))
  FileUtils.ln_sf(File.join(src, 'system'), File.join(profile_path, 'system'))
end

search = JSON.load(File.read(File.join(src, 'search.json.in')))
hash = FirefoxHashGenerator.generate(:waterfox, profile_basename, 'DuckDuckGo')
search['metaData'] = {
  current: 'DuckDuckGo',
  hash: hash,
}
search = JSON.dump(search)
# https://github.com/dearblue/ruby-extlz4
# https://gist.github.com/Tblue/62ff47bef7f894e92ed5
# https://gist.github.com/kaefer3000/73febe1eec898cd50ce4de1af79a332a
# use lz4jsoncat in lz4json debian package to verify
require 'extlz4'
File.open(File.join(profile_path, 'search.json.mozlz4'), 'wb') do |f|
  f << "mozLz40\0"
  f << [search.length].pack('l<')
  f << LZ4.block_encode(search)
end

if certs = options[:ca_certs]
  db_dir = profile_path
  FileUtils.mkdir_p(db_dir)

  unless File.exist?(File.join(db_dir, 'pkcs11.txt'))
    #system("certutil -d dbm:#{db_dir} -N --empty-password")
  end

  certs.each do |ca_path|
    puts "Adding #{ca_path}"
    system("certutil -d dbm:#{db_dir} -A -n '#{File.basename(ca_path)}' -t 'TCu,Cu,Tu' -i '#{ca_path}'")
  end
end

require 'zip'
require 'active_support'
require 'active_support/core_ext/hash/conversions'
require 'active_support/core_ext/hash/indifferent_access'

class PackedExtension
  def initialize(path)
    @path = path
  end

  attr_reader :path

  def ext_id
    desc.fetch('id')
  end

  %w(bootstrap unpack version name description creator).each do |key|
    define_method(key) do
      desc.fetch(key)
    end
  end

  def target_application
    desc.fetch('targetApplication')
  end

  def metadata
    @metadata ||= begin
      install_xml = nil
      Zip::File.open(path) do |zip|
        zip.each do |entry|
          if entry.name == 'install.rdf'
            install_xml = entry.get_input_stream.read
          end
        end
      end

      if install_xml.nil?
        raise "No install.rdf in #{path} - not a fox extension?"
      end

      Hash.from_xml(install_xml)
    end
  end

  private

  def desc
    @desc ||= metadata.fetch('RDF').fetch('Description')
  end
end

class ExtensionsMetadata
  def initialize(path)
    @path = path

    load!
  end

  attr_reader :path

  def load!
    data = if File.exist?(path)
      JSON.load(File.read(path))
    else
      {
        schemaVersion: 24,
        addons: addons,
      }
    end
    @data = ActiveSupport::HashWithIndifferentAccess.new(data)
  end

  attr_reader :data

  def addon(name)
    data.fetch(:addons).detect do |addon|
      # Not all addons have names
      addon[:name] == name
    end
  end

  def set_addon(name, info)
    found = false
    data.fetch(:addons).each do |addon|
      if addon[:name] == name
        found = true
        addon.update(info)
        break
      end
    end
    unless found
      data[:addons] << ActiveSupport::HashWithIndifferentAccess.new(info).update('name' => name)
    end
  end

  def dump!
    File.open(path, 'w') do |f|
      f << data
    end
  end
end

if exts = options[:extensions]
  addons = []
  metadata_path = File.join(profile_path, 'extensions.json')
  md = ExtensionsMetadata.new(metadata_path)

  exts.each do |ext_path|
    ext = PackedExtension.new(ext_path)

    ext_dir = File.join(profile_path, 'extensions')
    FileUtils.mkdir_p(ext_dir)
    FileUtils.cp(ext_path, File.join(ext_dir, "#{ext.ext_id}.xpi"))

    info = md.addon(ext.name) || {}
    info.update(
      id: ext.ext_id,
      location: 'app-profile',
      version: ext.version,
      type: 'extension',
      bootstrap: ext.bootstrap,
      defaultLocale: {
        name: ext.name,
        description: ext.description,
        creator: ext.creator,
        homepageURL: nil,
      },
      visible: true,
      active: true,
      userDisabled: false,
      appDisabled: false,
      targetApplications: [ext.target_application],
      path: File.realpath(ext_path),
    )
    md.set_addon(ext.name, info)
  end

  md.dump!
end

# Waterfox and waterfox classic put profiles in the same place, ugh.
#exec(binary, '-P', profile)
exec(binary, '--profile', '-no-remote', profile_path)
