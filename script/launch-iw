#!/usr/bin/env ruby

# https://www.ghacks.net/2016/08/14/override-firefox-add-on-signing-requirement/
# https://firefox-source-docs.mozilla.org/mozbase/mozprofile.html

require 'optparse'

options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: launch-iw [-c cert] [-e ext.xpi] [-u user] binary profile"

  opts.on("-c", "--ca=PATH", "Add a CA certificate to trust store") do |value|
    options[:ca_certs] ||= []
    options[:ca_certs] << value
  end

  opts.on("-e", "--ext PATH", "Load unpacked extension at PATH") do |v|
    options[:extensions] ||= []
    options[:extensions] << v
  end

  opts.on("-u", "--user USER", "Launch as given user") do |v|
    options[:user] = v
  end
end.parse!

binary, profile = ARGV

if profile.nil?
  raise "Usage: launch-iw [-u user] binary profile"
end

require 'etc'

target_user = options[:user] || profile
unless target_user.start_with?('br-')
  target_user = "br-#{target_user}"
end
if Etc.getpwuid(Process.euid).name != target_user
  begin
    Etc.getpwnam(target_user)
  rescue ArgumentError => e
    if e.message =~ /can't find user/
      if options[:user]
        # User was explicitly requested
        raise
      else
        # Ignore
      end
    else
      raise
    end
  else
    puts "Relaunching as #{target_user}"
    auths = `xauth list`.strip.split("\n")
    auths.each do |auth|
      cmd = %w(sudo -u) + [target_user] + %w(env) + ["XAUTHORITY=/home/#{target_user}/.Xauthority"] + %w(xauth add) + auth.split(/\s+/)
      puts "Executing #{cmd.join(' ')}"
      if fork
        Process.wait
      else
        exec(*cmd)
      end
    end
    if certs = options[:ca_certs]
      certs.each do |ca_path|
        ARGV << '-c' << ca_path
      end
    end
    cmd = %w(sudo -u) + [target_user, 'env', "XAUTHORITY=/home/#{target_user}/.Xauthority", File.realpath(File.expand_path($0))]
    options[:extensions]&.each do |ext|
      cmd += ['-e', ext]
    end
    cmd += ARGV
    puts "Executing #{cmd.join(' ')}"
    exec(*cmd)
  end
end

profile_dir = case File.basename(binary)
when 'waterfox'
  if binary =~ /waterfox-classic/
    '.waterfox-classic'
  else
    '.waterfox'
  end
when 'firefox'
  '.mozilla/firefox'
when 'palemoon'
  '.moonchild productions/pale moon'
else
  raise "Unknown browser #{binary}"
end

catalog_dir = File.join(File.expand_path('~'), profile_dir)

catalog_path = File.join(catalog_dir, 'profiles.ini')
profile_basename = "gen.#{profile}"
profile_path = File.join(catalog_dir, profile_basename)

require 'inifile'
require 'fileutils'
require 'tmpdir'
require 'json'
require 'firefox_hash_generator'

if File.exist?(catalog_path)
  ini = IniFile.new(filename: catalog_path, separator: '')
else
  ini = IniFile.new(separator: '')
end

ini['Profile0'] = {
  Name: profile,
  IsRelative: 1,
  Path: profile_basename,
}

FileUtils.mkdir_p(catalog_dir)
ini.write(filename: catalog_path)

FileUtils.mkdir_p(profile_path)

src = File.expand_path(File.join(File.dirname(__FILE__), '../home/mozilla'))

chrome_path = File.join(profile_path, 'chrome')
FileUtils.mkdir_p(chrome_path)
FileUtils.ln_sf(File.join(src, 'userChrome.css'), File.join(chrome_path, 'userChrome.css'))
FileUtils.ln_sf(File.join(src, 'userContent.css'), File.join(chrome_path, 'userContent.css'))
FileUtils.ln_sf(File.join(src, 'user.js'), File.join(profile_path, 'user.js'))
unless File.exist?(File.join(profile_path, 'system'))
  FileUtils.ln_sf(File.join(src, 'system'), File.join(profile_path, 'system'))
end

search = JSON.load(File.read(File.join(src, 'search.json.in')))
hash = FirefoxHashGenerator.generate(:waterfox, profile_basename, 'DuckDuckGo')
search['metaData'] = {
  current: 'DuckDuckGo',
  hash: hash,
}
search = JSON.dump(search)
# https://github.com/dearblue/ruby-extlz4
# https://gist.github.com/Tblue/62ff47bef7f894e92ed5
# https://gist.github.com/kaefer3000/73febe1eec898cd50ce4de1af79a332a
# use lz4jsoncat in lz4json debian package to verify
require 'extlz4'
File.open(File.join(profile_path, 'search.json.mozlz4'), 'wb') do |f|
  f << "mozLz40\0"
  f << [search.length].pack('l<')
  f << LZ4.block_encode(search)
end

if certs = options[:ca_certs]
  db_dir = profile_path
  FileUtils.mkdir_p(db_dir)

  unless File.exist?(File.join(db_dir, 'pkcs11.txt'))
    #system("certutil -d dbm:#{db_dir} -N --empty-password")
  end

  certs.each do |ca_path|
    puts "Adding #{ca_path}"
    system("certutil -d dbm:#{db_dir} -A -n '#{File.basename(ca_path)}' -t 'TCu,Cu,Tu' -i '#{ca_path}'")
  end
end

require 'zip'
require 'active_support'
require 'active_support/core_ext/hash/conversions'

class PackedExtension
  def initialize(path)
    @path = path
  end

  attr_reader :path

  def ext_id
    @ext_id ||= metadata.fetch('RDF').fetch('Description').fetch('id')
  end

  def metadata
    @metadata ||= begin
      install_xml = nil
      Zip::File.open(path) do |zip|
        zip.each do |entry|
          if entry.name == 'install.rdf'
            install_xml = entry.get_input_stream.read
          end
        end
      end

      if install_xml.nil?
        raise "No install.rdf in #{path} - not a fox extension?"
      end

      Hash.from_xml(install_xml)
    end
  end
end

options[:extensions]&.each do |ext_path|
  ext = PackedExtension.new(ext_path)
  ext_id = ext.ext_id

  ext_dir = File.join(profile_path, 'extensions')
  FileUtils.mkdir_p(ext_dir)
  FileUtils.cp(ext_path, File.join(ext_dir, "#{ext_id}.xpi"))
end

# Waterfox and waterfox classic put profiles in the same place, ugh.
#exec(binary, '-P', profile)
exec(binary, '--profile', '-no-remote', profile_path)
