#!/usr/bin/env ruby

require 'optparse'
require 'digest'
require 'find'
require 'fileutils'
require 'mongo'

class InsertThread
  def initialize(coll, insert_queue, done_queue)
    @coll, @insert_queue = coll, insert_queue
    @done_queue = done_queue
  end

  attr_reader :coll, :insert_queue
  attr_reader :done_queue

  def start
    Thread.new do
      loop do
        batch = []
        loop do
          batch << insert_queue.pop(true)
          break if batch.length > 100
        rescue ThreadError
          break
        end

        if batch.empty?
          sleep 1
        else
          coll.insert_many(batch)
          STDOUT << "i#{batch.length} "
        end

        break if insert_queue.empty? && !done_queue.empty?
      end
    end
  end
end

class Processor
  def initialize(start)
    @start = start
  end

  attr_reader :start

  def db_client
    @db_client ||= Mongo::Client.new('mongodb://127.0.0.1:27017/dups')
  end

  def coll
    @coll ||= db_client[:files]
  end

  def dir_coll
    @dir_coll ||= db_client[:dirs]
  end

  def entries_in_dir(path)
    Dir.entries(path).reject do |entry|
      entry == '.' || entry == '..'
    end
  end

  def relativize(path)
    (path[start.length..] || '').sub(%r,\A/,, '')
  end

  def absolutize(path)
    File.join(start, path)
  end

  def find
    coll.indexes.create_one({rel_path: 1}, unique: true)
    #coll.delete_many

    found_files = Queue.new
    done_find = Queue.new
    insert_queue = Queue.new
    done_process = Queue.new
    dir_contents = Queue.new

    find_thread = Thread.new do
      count = 0
      Find.find(start) do |path|
        if File.directory?(path)
          if File.basename(path) == 'lost+found'
            next
          end
          rel_dir_path = relativize(path)
          if rel_dir_path != '' && !File.symlink?(path)
            dir_contents << [rel_dir_path, entries_in_dir(path)]
          end
        elsif File.file?(path)
          rel = relativize(path)
          found_files << rel
          count += 1
          if count % 1000 == 0
            STDOUT << '.'
            sleep 0
          end
        elsif File.symlink?(path)
          # ignore
        else
          raise NotImplementedError
        end
      end
      done_find << true
    end

    processed = {}
    in_db = {}

    process_thread = Thread.new do
      coll.find.projection(rel_path: 1, sha256: 1).each do |doc|
        processed[doc.fetch(:rel_path)] = doc.fetch(:sha256)
        in_db[doc.fetch(:rel_path)] = true
      end

      loop do
        loop do
          begin
            rel_path = found_files.pop(true)
          rescue ThreadError
            sleep 1
            break
          end

          next if processed.key?(rel_path)

          sha256 = Digest::SHA256.file(File.join(start, rel_path))
          digest = sha256.hexdigest
          insert_queue << {rel_path: rel_path, sha256: digest}
          processed[rel_path] = sha256
          STDOUT << 'h'
        end
        break if found_files.empty? && !done_find.empty?
        sleep 0
      end
      done_process << true
    end

    insert_thread = InsertThread.new(coll, insert_queue, done_process).start

    find_thread.join
    process_thread.join

    dir_hashes = {}
    dir_done_process = Queue.new
    dir_insert_queue = Queue.new

    dir_thread = Thread.new do
      skipped = []
      until skipped.empty? && dir_contents.empty?
        did_anything = false
        STDOUT << '?'
        until dir_contents.empty?
          rel_dir_path, entries = dir_contents.pop
          begin
            shas = entries.map do |entry|
              rel_path = File.join(rel_dir_path, entry)
              entry_path = absolutize(rel_path)
              if File.symlink?(entry_path)
                'S'
              else
                dir_hashes[rel_path] || processed.fetch(rel_path)
              end
            end
            dir_sha = sum("d:#{rel_dir_path};#{entries.length};#{shas.join(',')}")
            dir_hashes[rel_dir_path] = dir_sha
            dir_insert_queue << {rel_path: rel_dir_path, sha256: dir_sha}
            did_anything = true
          rescue KeyError => exc
            puts "#{exc.class}: #{exc}"
            skipped << [rel_dir_path, entries]
          end
        end
        if skipped.count > 0
          puts "\n#{skipped.count} skipped"
          sleep 1
          skipped.each do |item|
            dir_contents.push(item)
          end
          if skipped.length < 10
            puts "\nSkipped:"
            skipped.each do |path|
              p path
            end
          end
          skipped.replace([])
        else
          sleep 0.2
        end
      end
      dir_done_process << true
    end

    # There aren't many directories out there and they are easy to recompute.
    puts 'Replacing dirs in db'
    dir_coll.delete_many
    dir_insert_thread = InsertThread.new(dir_coll, dir_insert_queue, dir_done_process).start

    insert_thread.join
    dir_thread.join

    puts 'Pruning'
    prune_thread = Thread.new do
      rel_paths = in_db.keys - processed.keys
      if rel_paths.any?
        puts "Deleting #{rel_paths.count}"
        p coll.delete_many(rel_path: {'$in': rel_paths})
      end
    end

    puts 'Waiting'
    dir_insert_thread.join
    prune_thread.join
  end

  def sum(text)
    Digest::SHA256.new.update(text).hexdigest
  end

  def show_dirs
    view = dir_coll.aggregate([
      {'$group': {_id: '$sha256',
        count: {'$count': {}},
        rel_paths: {'$push': '$rel_path'},
      }},
      {'$match': {count: {'$gt': 1}}},
      {'$sort': {count: -1}},
    ])
    p view.count
    view.take(100).each do |doc|
      p doc
    end
  end

  def show_files
    view = coll.aggregate([
      {'$group': {_id: '$sha256',
        count: {'$count': {}},
        rel_paths: {'$push': '$rel_path'},
      }},
      {'$match': {count: {'$gt': 1}}},
      {'$sort': {count: -1}},
    ])
    p view.count
    view.take(100).each do |doc|
      p doc
    end
  end
end

options = {}

OptionParser.new do |opts|
  opts.on('-d', 'Show duplicate dirs') do
    options[:show_dirs] = true
  end

  opts.on('-s', 'Show duplicate files') do
    options[:show_files] = true
  end
end.parse!

processor = Processor.new(ARGV.shift || '.')
if options[:show_dirs]
  processor.show_dirs
elsif options[:show_files]
  processor.show_files
else
  processor.find
end
