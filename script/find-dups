#!/usr/bin/env ruby

require 'optparse'
require 'digest'
require 'find'
require 'fileutils'
require 'mongo'

class Processor
  def initialize(start)
    @start = start
  end

  attr_reader :start

  def db_client
    @db_client ||= Mongo::Client.new('mongodb://127.0.0.1:27017/dups')
  end

  def coll
    @coll ||= db_client[:files]
  end

  def entries_in_dir(path)
    Dir.entries(path).reject do |entry|
      entry == '.' || entry == '..'
    end
  end

  def relativize(path)
    path[start.length..].sub(%r,\A/,, '')
  end

  def find
    coll.indexes.create_one({rel_path: 1}, unique: true)
    #coll.delete_many

    found_files = Queue.new
    done_find = Queue.new
    insert_queue = Queue.new
    done_process = Queue.new
    dir_contents = Queue.new

    find_thread = Thread.new do
      count = 0
      Find.find(start) do |path|
        if File.directory?(path)
          if File.basename(path) == 'lost+found'
            next
          end
          dir_contents << [path, entries_in_dir(path)]
        elsif File.file?(path)
          rel = relativize(path)
          found_files << rel
          count += 1
          if count % 1000 == 0
            STDOUT << '.'
            sleep 0
          end
        elsif File.symlink?(path)
          # ignore
        else
          raise NotImplementedError
        end
      end
      done_find << true
    end

    processed = {}

    process_thread = Thread.new do
      coll.find.projection(rel_path: 1, sha256: 1).each do |doc|
        processed[doc.fetch(:rel_path)] = doc.fetch(:sha256)
      end

      loop do
        loop do
          begin
            rel_path = found_files.pop(true)
          rescue ThreadError
            sleep 1
            break
          end

          next if processed.key?(rel_path)

          sha256 = Digest::SHA256.file(File.join(start, rel_path))
          digest = sha256.hexdigest
          insert_queue << {rel_path: rel_path, sha256: digest}
          processed[rel_path] = sha256
          STDOUT << 'h'
        end
        break if found_files.empty? && !done_find.empty?
        sleep 0
      end
      done_process << true
    end

    insert_thread = Thread.new do
      loop do
        batch = []
        loop do
          batch << insert_queue.pop(true)
          break if batch.length > 100
        rescue ThreadError
          break
        end

        if batch.empty?
          sleep 1
        else
          coll.insert_many(batch)
          STDOUT << "i#{batch.length} "
        end

        break if insert_queue.empty? && !done_process.empty?
      end
    end

    find_thread.join
    process_thread.join

    dir_hashes = {}

    dir_thread = Thread.new do
      skipped = []
      until skipped.empty? && dir_contents.empty?
        until dir_contents.empty?
          begin
            dir_path, entries = dir_contents.pop
            rel_dir_path = relativize(dir_path)
            shas = entries.map do |entry|
              entry_path = File.join(dir_path, entry)
              rel_path = relativize(entry_path)
              if File.symlink?(entry_path)
                'S'
              else
                dir_hashes[rel_path] || processed.fetch(rel_path)
              end
            end
            dir_sha = sum("d:#{dir_path};#{entries.length};#{shas.join(',')}")
            dir_hashes[rel_dir_path] = dir_sha
          rescue KeyError
            skipped << [dir_path, entries]
          end
        end
        if skipped.count > 0
          puts "\n#{skipped.count} skipped"
          sleep 0.1
          skipped.each do |item|
            dir_contents.push(item)
          end
          skipped.replace([])
        end
      end
    end

    insert_thread.join
    dir_thread.join
  end

  def sum(text)
    Digest::SHA256.new.update(text).hexdigest
  end

  def show_dups
    view = coll.aggregate([
      {'$group': {_id: '$sha256',
        count: {'$count': {}},
        rel_paths: {'$push': '$rel_path'},
      }},
      {'$match': {count: {'$gt': 1}}},
      {'$sort': {count: -1}},
    ])
    p view.count
    view.take(100).each do |doc|
      p doc
    end
  end
end

options = {}

OptionParser.new do |opts|
  opts.on('-s', 'Show duplicates') do
    options[:show] = true
  end
end.parse!

processor = Processor.new(ARGV.shift || '.')
if options[:show]
  processor.show_dups
else
  processor.find
end
